<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Unicorn Jumper — Polished Visuals</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  body{background:linear-gradient(#bfeaff,#ffffff);overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  .hud{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.45);color:#fff;border-radius:10px;padding:8px 12px;font-size:14px;z-index:10}
  .hint{position:fixed;right:12px;top:12px;background:rgba(0,0,0,.45);color:#fff;border-radius:10px;padding:8px 12px;font-size:13px;z-index:10}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">Score: <span id="score">0</span></div>
<div class="hint">Tap / Space to jump • Hold to jump higher • Double jump enabled</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

/* ===== Game State ===== */
const unicorn = {
  x: 80, y: canvas.height - 150, w: 90, h: 72,
  dy: 0, gravity: 0.60, jumpPower: -18,
  grounded: false, canDouble: true, jumping: false, faceRight: true
};

let clouds = [];
let rings = [];
let fireballs = [];
let score = 0;
let gameOver = false;
let spaceHeld = false;
let last = performance.now();

/* ===== Init Clouds ===== */
for(let i=0;i<8;i++){
  clouds.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height*0.45 + canvas.height*0.1,
    r: 28 + Math.random()*18,
    s: 0.3 + Math.random()*0.5
  });
}

/* ===== Input ===== */
function tryJump(){
  if(unicorn.grounded){
    unicorn.dy = unicorn.jumpPower;
    unicorn.grounded = false;
    unicorn.canDouble = true;
    unicorn.jumping = true;
  }else if(unicorn.canDouble){
    unicorn.dy = unicorn.jumpPower * 0.9;
    unicorn.canDouble = false;
    unicorn.jumping = true;
  }
}
function endJump(){ unicorn.jumping = false; }

addEventListener('keydown', e=>{
  if(e.code === 'Space'){ if(!spaceHeld){ tryJump(); } spaceHeld = true; }
  if(e.code === 'ArrowRight'){ unicorn.faceRight = true; }
  if(e.code === 'ArrowLeft'){ unicorn.faceRight = false; }
  if(gameOver && (e.code==='KeyR' || e.code==='Space')) location.reload();
});
addEventListener('keyup', e=>{ if(e.code === 'Space'){ spaceHeld = false; endJump(); }});
addEventListener('touchstart', e=>{ e.preventDefault(); if(gameOver){ location.reload(); } else { tryJump(); spaceHeld=true; } }, {passive:false});
addEventListener('touchend',   e=>{ e.preventDefault(); spaceHeld=false; endJump(); }, {passive:false});

/* ===== Spawners ===== */
let ringT=0, fireT=0, difficulty=1, diffT=0;
function spawnRing(){
  const y = Math.random()*(canvas.height*0.35) + canvas.height*0.35; // 35–70% height
  rings.push({ x: canvas.width + 60, y, r: 18, s: 3.6 + 0.3*difficulty });
}
function spawnFireball(){
  const y = Math.random()*(canvas.height*0.5) + canvas.height*0.2;
  fireballs.push({
    x: canvas.width + 60,
    y, r: 16, s: 5.2 + 0.35*difficulty,
    t: Math.random()*1000 // for flicker
  });
}

/* ===== Drawing Helpers ===== */
function drawCloud(x,y,r){
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.arc(x+r*0.8, y+r*0.2, r*0.8, 0, Math.PI*2);
  ctx.arc(x-r*0.9, y+r*0.25, r*0.9, 0, Math.PI*2);
  ctx.fill();
}

function drawRing(x,y,r){
  // gold ring with shine
  ctx.lineWidth = Math.max(4, r*0.45);
  const g = ctx.createLinearGradient(x-r,y-r,x+r,y+r);
  g.addColorStop(0,'#ffe680');
  g.addColorStop(1,'#ffbf00');
  ctx.strokeStyle = g;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.stroke();
  // spec highlight
  ctx.lineWidth = Math.max(2, r*0.18);
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.arc(x-r*0.2,y-r*0.2,r*0.6, -0.3, 1.0);
  ctx.stroke();
}

function drawFireball(obj, t){
  const {x,y,r} = obj;
  const flick = Math.sin((t+obj.t)/90)*0.6 + 1;
  const tail = r*2.6 * flick;

  // tail glow
  const grad = ctx.createRadialGradient(x, y, 0, x, y, r+22);
  grad.addColorStop(0, 'rgba(255,120,60,0.95)');
  grad.addColorStop(1, 'rgba(255,120,60,0)');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(x, y, r+22, 0, Math.PI*2); ctx.fill();

  // comet tail
  ctx.fillStyle = '#ff7a59';
  ctx.beginPath();
  ctx.moveTo(x - tail, y);
  ctx.quadraticCurveTo(x - tail*0.6, y - r*1.1, x - r*0.2, y - r*0.3);
  ctx.lineTo(x - r*0.1, y + r*0.4);
  ctx.quadraticCurveTo(x - tail*0.7, y + r*1.1, x - tail, y);
  ctx.closePath(); ctx.fill();

  // core
  ctx.fillStyle = '#ff4b4b';
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();

  // tiny spark
  ctx.fillStyle = 'rgba(255,230,180,0.85)';
  ctx.beginPath(); ctx.arc(x+r*0.2, y-r*0.2, r*0.25, 0, Math.PI*2); ctx.fill();
}

function drawUnicorn(u, t){
  // subtle bob while airborne
  const bob = u.grounded ? 0 : Math.sin(t/120)*1.5;

  ctx.save();
  ctx.translate(u.x, u.y + bob);

  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.beginPath();
  ctx.ellipse(u.w*0.45, u.h+12, u.w*0.4, 10, 0, 0, Math.PI*2);
  ctx.fill();

  // tail (rainbow)
  const tailX = u.faceRight ? u.w*0.08 : u.w*0.92;
  for(let i=0;i<4;i++){
    const colors=['#ff7ad9','#ffcc00','#7afcff','#9dff7a'];
    ctx.strokeStyle = colors[i];
    ctx.lineWidth = 6 - i;
    ctx.beginPath();
    const dir = u.faceRight ? -1 : 1;
    ctx.moveTo(tailX, u.h*0.65 + i*3);
    ctx.quadraticCurveTo(tailX + dir*30, u.h*0.75 + i*3, tailX + dir*55, u.h*0.65 + i*3);
    ctx.stroke();
  }

  // body
  ctx.fillStyle = '#ffffff';
  roundRect( ctx, u.faceRight?u.w*0.12:u.w*0.08, u.h*0.25, u.w*0.72, u.h*0.55, 14, true );

  // legs
  ctx.fillStyle = '#f2f2f2';
  const legW = u.w*0.12, legH = u.h*0.35;
  const legX = [u.w*0.22, u.w*0.36, u.w*0.56, u.w*0.70];
  for(let i=0;i<4;i++){
    roundRect(ctx, legX[i], u.h*0.65, legW, legH, 6, true);
  }

  // head
  const headX = u.faceRight? u.w*0.66 : u.w*0.22;
  ctx.fillStyle = '#ffffff';
  roundRect(ctx, headX, u.h*0.1, u.w*0.28, u.h*0.34, 12, true);

  // ear
  ctx.fillStyle = '#ffe3f4';
  ctx.beginPath();
  const earX = u.faceRight? headX + u.w*0.18 : headX + u.w*0.06;
  ctx.moveTo(earX, u.h*0.05);
  ctx.lineTo(earX + (u.faceRight?10:-10), u.h*0.00);
  ctx.lineTo(earX + (u.faceRight?0:0), u.h*0.14);
  ctx.closePath(); ctx.fill();

  // horn
  ctx.fillStyle = '#ffd166';
  ctx.beginPath();
  const hornBaseX = u.faceRight? headX + u.w*0.26 : headX + u.w*0.02;
  ctx.moveTo(hornBaseX, u.h*0.08);
  ctx.lineTo(hornBaseX + (u.faceRight?16:-16), u.h*0.00);
  ctx.lineTo(hornBaseX + (u.faceRight?6:-6),  u.h*0.16);
  ctx.closePath(); ctx.fill();

  // mane (3 strokes)
  const maneColors=['#7a4bff','#ff7ad9','#7afcff'];
  for(let i=0;i<3;i++){
    ctx.strokeStyle = maneColors[i];
    ctx.lineWidth = 5;
    ctx.beginPath();
    const mx = u.faceRight ? headX-8 : headX+u.w*0.28+8;
    const dir = u.faceRight? -1: 1;
    ctx.moveTo(mx, u.h*0.18 + i*6);
    ctx.quadraticCurveTo(mx + dir*22, u.h*0.28 + i*6, mx + dir*10, u.h*0.40 + i*6);
    ctx.stroke();
  }

  // eye
  const eyeX = u.faceRight? headX + u.w*0.18 : headX + u.w*0.08;
  ctx.fillStyle = '#0b1020';
  ctx.beginPath(); ctx.arc(eyeX, u.h*0.23, 3.6, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r,fill){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  if(fill) ctx.fill(); else ctx.stroke();
}

/* ===== Collision ===== */
function collideRectCircle(rx,ry,rw,rh,cx,cy,cr){
  const testX = Math.max(rx, Math.min(cx, rx+rw));
  const testY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - testX, dy = cy - testY;
  return (dx*dx + dy*dy) <= cr*cr;
}

/* ===== Main Loop ===== */
function update(now){
  const dt = Math.min(50, now - last); last = now;

  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // clouds
  clouds.forEach(c=>{
    c.x -= c.s;
    if(c.x < -120){ c.x = canvas.width + 120; c.y = Math.random()*canvas.height*0.45 + canvas.height*0.1; c.r = 24 + Math.random()*20; }
    drawCloud(c.x,c.y,c.r);
  });

  // unicorn physics (variable jump height)
  let g = unicorn.gravity;
  if(unicorn.dy < 0 && spaceHeld) g *= 0.35; // sustain rise while held
  unicorn.dy += g;
  unicorn.y  += unicorn.dy;

  // floor
  const floorY = canvas.height - 70;
  if(unicorn.y + unicorn.h >= floorY){
    unicorn.y = floorY - unicorn.h;
    unicorn.dy = 0;
    unicorn.grounded = true;
    unicorn.jumping = false;
  } else {
    unicorn.grounded = false;
  }

  // spawn cadence
  ringT += dt; fireT += dt; diffT += dt;
  if(ringT > 1200){ spawnRing(); ringT = 0; }
  if(fireT > 1700){ spawnFireball(); fireT = 0; }
  if(diffT > 20000){ difficulty = Math.min(3, difficulty+0.2); diffT = 0; }

  // rings
  for(let i=rings.length-1;i>=0;i--){
    const r = rings[i]; r.x -= r.s;
    drawRing(r.x, r.y, r.r);
    if(collideRectCircle(unicorn.x,unicorn.y,unicorn.w,unicorn.h, r.x,r.y,r.r)){
      rings.splice(i,1); score += 10; scoreEl.textContent = score;
    }else if(r.x + r.r < -10){ rings.splice(i,1); }
  }

  // fireballs
  for(let i=fireballs.length-1;i>=0;i--){
    const f = fireballs[i]; f.x -= f.s;
    drawFireball(f, now);
    if(collideRectCircle(unicorn.x,unicorn.y,unicorn.w,unicorn.h, f.x,f.y,f.r)){
      gameOver = true;
    }else if(f.x + f.r < -10){ fireballs.splice(i,1); }
  }

  // unicorn
  drawUnicorn(unicorn, now);

  // ground strip
  ctx.fillStyle = '#e9f7ff';
  ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

  if(!gameOver){ requestAnimationFrame(update); }
  else{
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px Arial';
    ctx.fillText('Game Over', canvas.width/2 - 120, canvas.height/2 - 10);
    ctx.font = '20px Arial';
    ctx.fillText('Press R or Tap to Restart', canvas.width/2 - 120, canvas.height/2 + 26);
  }
}

requestAnimationFrame(update);
</script>
</body>
</html>
