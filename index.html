<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unicorn Jumper ‚Äì Polished</title>
<style>
  html,body{height:100%;margin:0;background:linear-gradient(#9de1ff,#ffffff);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  #game{width:100vw;height:100vh;overflow:hidden}
  .ui{
    position:fixed;inset:auto 12px 12px auto;z-index:10;
    background:rgba(0,0,0,.45);color:#fff;border-radius:10px;padding:8px 12px;font-size:14px
  }
  .overlay{
    position:fixed;inset:0;display:grid;place-items:center;background:linear-gradient(rgba(255,255,255,.85),rgba(255,255,255,.75));
    z-index:20
  }
  .card{background:#fff;border:1px solid #e7ecf3;border-radius:16px;max-width:520px;padding:22px;box-shadow:0 6px 28px rgba(0,0,0,.08);text-align:center}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .btn{cursor:pointer;border:1px solid #111;background:#111;color:#fff;border-radius:12px;padding:12px 16px;font-weight:700}
  .btn.ghost{background:#fff;color:#111;border-color:#e7ecf3}
  .muted{opacity:.7}
</style>
</head>
<body>
<div id="game"></div>
<div class="ui" id="hud" style="display:none">Score: <span id="score">0</span></div>

<div class="overlay" id="startOv">
  <div class="card">
    <h2>ü¶Ñ Unicorn Jumper</h2>
    <p class="muted">Tap / Space to jump. Collect rings. Dodge fireballs.</p>
    <div class="row">
      <button class="btn" id="startBtn">Start</button>
      <button class="btn ghost" id="howBtn">How to Play</button>
    </div>
    <p class="muted" id="how" style="display:none;margin-top:10px">
      ‚Ä¢ Jump any time (air jump disabled)<br/>
      ‚Ä¢ You get <b>coyote time</b> and <b>jump buffering</b> for smoother feel<br/>
      ‚Ä¢ Difficulty ramps every 20s
    </p>
  </div>
</div>

<div class="overlay" id="overOv" style="display:none">
  <div class="card">
    <h2>Game Over</h2>
    <p class="muted">Score: <span id="finalScore">0</span></p>
    <div class="row">
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/phaser@3.70.0/dist/phaser.min.js"></script>
<script>
(() => {
  // Basic dimensions
  const W = window.innerWidth, H = window.innerHeight;

  // UI refs
  const startOv = document.getElementById('startOv');
  const overOv  = document.getElementById('overOv');
  const startBtn= document.getElementById('startBtn');
  const howBtn  = document.getElementById('howBtn');
  const howTxt  = document.getElementById('how');
  const restartBtn = document.getElementById('restartBtn');
  const hud     = document.getElementById('hud');
  const scoreEl = document.getElementById('score');
  const finalEl = document.getElementById('finalScore');

  howBtn.onclick = () => { howTxt.style.display = howTxt.style.display ? '' : 'block'; };

  const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: W,
    height: H,
    physics: {
      default: 'arcade',
      arcade: {
        gravity: { y: 1800 },
        fps: 60,
        debug: false
      }
    },
    scene: { preload, create, update }
  };

  let game, player, ground, clouds, coins, fireballs, sparkles;
  let cursors, pointerDown = false;
  let score = 0, started = false, gameOver = false;
  // Feel params
  const JUMP_VELOCITY = -680;
  const COYOTE_TIME_MS = 120;     // grace window after leaving ground
  const JUMP_BUFFER_MS = 120;     // window before landing to queue a jump
  let coyoteTimer = 0, jumpBufferTimer = 0;
  let ringSpawn = 1300, fireSpawn = 1800, speedScale = 1, lastRamp = 0;

  function preload(){
    // procedural graphics ‚Äî no external assets
    this.textures.generate('cloud', { data: drawCloud(64,40), pixelWidth: 2 });
    this.textures.generate('ring',  { data: drawRing(28),    pixelWidth: 2 });
    this.textures.generate('fire',  { data: drawFire(22),    pixelWidth: 2 });
    this.textures.generate('uni',   { data: drawUnicorn(44,34), pixelWidth: 2 });
    this.textures.generate('ground',{ data: drawGround(64,16), pixelWidth: 2 });
  }

  function create(){
    // Parallax clouds
    clouds = this.add.group();
    for(let i=0;i<8;i++){
      const c = this.add.image(Phaser.Math.Between(0,W), Phaser.Math.Between(40,H*0.5), 'cloud');
      c.setAlpha(0.9);
      c.speed = 0.2 + Math.random()*0.4;
      clouds.add(c);
    }

    // Ground
    ground = this.physics.add.staticGroup();
    for(let x=0;x<=W+64;x+=64){
      ground.create(x, H-60, 'ground').setOrigin(0.5,0.5).refreshBody();
    }

    // Player
    player = this.physics.add.image(120, H-120, 'uni');
    player.setDepth(10);
    player.setCollideWorldBounds(true);
    player.body.setSize(player.width*0.8, player.height*0.9);
    player.body.setOffset(player.width*0.1, player.height*0.05);
    this.physics.add.collider(player, ground, ()=>{ coyoteTimer = COYOTE_TIME_MS; });

    // Groups
    coins = this.physics.add.group();
    fireballs = this.physics.add.group();
    sparkles = this.add.particles(0,0,'ring').createEmitter({
      x:0,y:0, lifespan:400, speed: {min:40,max:120}, scale:{start:0.25,end:0}, quantity:0
    });

    // Overlaps
    this.physics.add.overlap(player, coins, (p,c)=>{
      score+=1; scoreEl.textContent = score;
      sparkles.explode(10, c.x, c.y);
      c.destroy();
    });
    this.physics.add.overlap(player, fireballs, ()=> endGame(this));

    // Input
    cursors = this.input.keyboard.createCursorKeys();
    this.input.keyboard.on('keydown-SPACE', queueJump);
    this.input.on('pointerdown', ()=>{ pointerDown = true; queueJump(); });
    this.input.on('pointerup',   ()=>{ pointerDown = false; });

    hud.style.display = 'none';
    overOv.style.display = 'none';

    // Timers
    this.time.addEvent({ delay: ringSpawn, loop:true, callback: ()=>spawnRing(this) });
    this.time.addEvent({ delay: fireSpawn, loop:true, callback: ()=>spawnFire(this) });

    // Difficulty ramp
    lastRamp = this.time.now;
  }

  function update(time, delta){
    // Scroll clouds
    clouds.children.iterate(c=>{
      c.x -= c.speed * (0.6 + speedScale*0.2);
      if(c.x < -80) c.x = W + 80, c.y = Phaser.Math.Between(40,H*0.5);
    });

    if(!started || gameOver) return;

    // Coyote & jump buffer timers
    coyoteTimer = Math.max(0, coyoteTimer - delta);
    jumpBufferTimer = Math.max(0, jumpBufferTimer - delta);

    // Apply queued jump when allowed
    const onGround = player.body.blocked.down;
    if(onGround) coyoteTimer = COYOTE_TIME_MS;
    if(jumpBufferTimer > 0 && (onGround || coyoteTimer>0)){
      doJump();
      jumpBufferTimer = 0;
      coyoteTimer = 0;
    }

    // Difficulty ramp every 20s
    if(time - lastRamp > 20000){
      lastRamp = time;
      speedScale = Math.min(2.2, speedScale + 0.15);
      ringSpawn = Math.max(700, ringSpawn - 80);
      fireSpawn = Math.max(950, fireSpawn - 80);
    }

    // Move hazards
    coins.children.iterate(c=>{ c.x -= 220*speedScale*delta/1000; if(c.x<-40) c.destroy(); });
    fireballs.children.iterate(f=>{ f.x -= 280*speedScale*delta/1000; if(f.x<-40) f.destroy(); });
  }

  // Start/Restart hooks
  document.getElementById('startBtn').onclick = ()=>{
    started = true; gameOver = false; score = 0; scoreEl.textContent = 0;
    hud.style.display = 'block';
    startOv.style.display = 'none';
  };
  document.getElementById('restartBtn').onclick = ()=>{
    location.reload(); // simplest clean reset for single-file demo
  };

  // Jump helpers with buffer & coyote time
  function queueJump(){
    if(gameOver || !started) return;
    jumpBufferTimer = JUMP_BUFFER_MS;
  }
  function doJump(){
    player.setVelocityY(JUMP_VELOCITY);
    // Tiny squash & stretch
    player.setScale(0.95,1.05);
    setTimeout(()=> player.setScale(1,1), 80);
  }

  function spawnRing(scene){
    if(!started || gameOver) return;
    const y = Phaser.Math.Between(H*0.2, H*0.65);
    const c = scene.physics.add.image(W+40, y, 'ring');
    c.body.setAllowGravity(false);
    coins.add(c);
  }
  function spawnFire(scene){
    if(!started || gameOver) return;
    const y = Phaser.Math.Between(H*0.25, H*0.7);
    const f = scene.physics.add.image(W+40, y, 'fire');
    f.body.setAllowGravity(false);
    fireballs.add(f);
  }

  function endGame(scene){
    if(gameOver) return;
    gameOver = true;
    scene.cameras.main.shake(180, 0.01);
    finalEl.textContent = score;
    hud.style.display = 'none';
    setTimeout(()=>{ overOv.style.display = 'grid'; }, 220);
  }

  // === Procedural ‚Äúart‚Äù ===
  function drawCloud(w,h){
    const cols = Math.ceil(w/2), rows = Math.ceil(h/2);
    const data = [];
    for(let y=0;y<rows;y++){
      let row = [];
      for(let x=0;x<cols;x++){
        const dx = (x-cols/2)/ (cols/2), dy = (y-rows/2)/ (rows/2);
        const v = Math.exp(-(dx*dx*2 + dy*dy*3));
        row.push(v>0.4 ? 'FFF' : '.');
      }
      data.push(row.join(''));
    }
    return data;
  }
  function drawRing(r){
    const d=[], s=r;
    for(let y=-s;y<=s;y++){
      let row='';
      for(let x=-s;x<=s;x++){
        const k=Math.sqrt(x*x+y*y);
        row += (k>r-3 && k<r+1) ? 'FFCC00' : '.';
      }
      d.push(row);
    }
    return d;
  }
  function drawFire(r){
    const d=[], s=r;
    for(let y=-s;y<=s;y++){
      let row='';
      for(let x=-s;x<=s;x++){
        const k=Math.sqrt(x*x+y*y);
        row += k<r ? (y<0 ? 'FF7A59' : 'FF4B4B') : '.';
      }
      d.push(row);
    }
    return d;
  }
  function drawUnicorn(w,h){
    const data=[];
    for(let y=0;y<h;y++){
      let row='';
      for(let x=0;x<w;x++){
        const edge = (x<2||y<2||x>w-3||y>h-3);
        const horn = (x>Math.floor(w*0.75) && y<Math.floor(h*0.35) && (x-y)>Math.floor(w*0.7)-6);
        const eye = (Math.abs(x-Math.floor(w*0.28))<2 && Math.abs(y-Math.floor(h*0.32))<2);
        row += horn ? 'FFD166' : eye ? '0B1020' : edge ? 'FF8BD9' : 'FF7AD9';
      }
      data.push(row);
    }
    return data;
  }
  function drawGround(w,h){
    const d=[];
    for(let y=0;y<h;y++){
      let row='';
      for(let x=0;x<w;x++){
        row += y>h/2 ? 'B7E6FF' : 'E9F7FF';
      }
      d.push(row);
    }
    return d;
  }

  game = new Phaser.Game(config);
})();
</script>
</body>
</html>
